# =============================================================================
# kmcp-servers Helm Values
# =============================================================================
#
# Este chart despliega MCP servers usando el CRD MCPServer de kmcp.
# kmcp controller gestiona automaticamente:
#   - Deployment (con Transport Adapter para stdio o HTTP nativo)
#   - Service (ClusterIP)
#   - ServiceAccount (con annotations para IRSA, Workload Identity, etc.)
#
# ARQUITECTURA:
#   - Namespace 'k2a': MCP Servers + Agent (unificado)
#   - Namespace 'kagent': Solo operador kagent (controller, ui, tools)
#   - Namespace 'kmcp-system': Solo operador kmcp (controller)
#
# NOTA: Las imagenes son Quarkus Native desde GitHub Container Registry.
#       Los Secrets y ConfigMaps se crean por separado.
#
# Prerequisitos:
#   - kmcp operator instalado (namespace: kmcp-system)
#   - CRD kagent.dev/MCPServer disponible
#   - Secrets creados en el namespace k2a
#
# Referencia: docs/KMCP-GUIA-CONFIGURACION.md
#
# =============================================================================

# ============================================
# GLOBAL CONFIGURATION
# ============================================
global:
  # Namespace unificado para MCP Servers y Agent
  namespace: k2a

# ============================================
# COMMON LABELS
# ============================================
common:
  labels:
    app.kubernetes.io/part-of: k2a-enterprise-monitoring

# ============================================
# RBAC
# ============================================
rbac:
  create: true
  serviceAccount:
    name: kmcp-servers
    annotations: {}
  # Custom ClusterRole for OpenShift Monitoring API access
  # Required for AlertManager and Prometheus MCP servers
  # The built-in cluster-monitoring-view doesn't include alertmanagers/api
  monitoringApiAccess:
    create: true
  # Optional: Additional ClusterRoleBinding for cluster-monitoring-view
  clusterRoleBinding:
    create: false  # Disabled - monitoringApiAccess provides all needed permissions
    clusterRole: cluster-monitoring-view

# ============================================
# NAMESPACE
# ============================================
namespace:
  create: true

# ============================================
# MCP SERVERS (Quarkus Native)
# ============================================
#
# Cada server crea un MCPServer CR (Custom Resource).
# El kmcp controller crea automaticamente:
#   - Deployment con HTTP nativo (Quarkus expone /mcp)
#   - Service ClusterIP
#   - ServiceAccount
#
# IMPORTANTE: Los servidores Quarkus usan HTTP nativo (streamable-http),
# por lo tanto se configura transportType: http
#
# ============================================

servers:
  # ------------------------------------------
  # Prometheus MCP Server (Quarkus Native)
  # ------------------------------------------
  prometheus:
    name: prometheus-mcp
    enabled: true
    description: "MCP Server para consultas PromQL a Prometheus/Thanos (Quarkus Native)"

    # HTTP Transport (Quarkus MCP usa streamable-http nativo)
    transportType: http

    # Imagen Quarkus Native desde GitHub Container Registry
    image:
      repository: ghcr.io/jeanlopezxyz/mcp-prometheus
      tag: "1.0.7"

    # Puerto del servidor HTTP (Quarkus config)
    port: 9081

    # No se necesita cmd/args - el container usa ENTRYPOINT ["./application"]

    # Variables de entorno
    env:
      PROMETHEUS_URL: "https://thanos-querier.openshift-monitoring.svc.cluster.local:9091"
      QUARKUS_HTTP_HOST: "0.0.0.0"
      QUARKUS_HTTP_PORT: "9081"

    # HTTP Transport configuration
    httpTransport:
      targetPort: 9081
      path: /mcp

    # Recursos (native image usa menos memoria)
    resources:
      requests:
        memory: "64Mi"
        cpu: "50m"
      limits:
        memory: "256Mi"
        cpu: "500m"

  # ------------------------------------------
  # AlertManager MCP Server (Quarkus Native)
  # ------------------------------------------
  alertmanager:
    name: alertmanager-mcp
    enabled: true
    description: "MCP Server para AlertManager (Quarkus Native)"

    # HTTP Transport
    transportType: http

    # Imagen Quarkus Native desde GitHub Container Registry
    image:
      repository: ghcr.io/jeanlopezxyz/mcp-alertmanager
      tag: "1.0.12"

    # Puerto del servidor HTTP
    port: 9082

    # Variables de entorno
    env:
      ALERTMANAGER_URL: "https://alertmanager-main.openshift-monitoring.svc.cluster.local:9094"
      QUARKUS_HTTP_HOST: "0.0.0.0"
      QUARKUS_HTTP_PORT: "9082"

    # HTTP Transport configuration
    httpTransport:
      targetPort: 9082
      path: /mcp

    # Recursos
    resources:
      requests:
        memory: "64Mi"
        cpu: "50m"
      limits:
        memory: "256Mi"
        cpu: "500m"

  # ------------------------------------------
  # Red Hat Cases MCP Server (Quarkus Native)
  # ------------------------------------------
  redhatCases:
    name: redhat-cases-mcp
    enabled: true
    description: "MCP Server para Red Hat KB y casos de soporte (Quarkus Native)"

    # HTTP Transport
    transportType: http

    # Imagen Quarkus Native desde GitHub Container Registry
    image:
      repository: ghcr.io/jeanlopezxyz/mcp-redhat-cases
      tag: "1.0.4"

    # Puerto del servidor HTTP
    port: 9080

    # Variables de entorno
    env:
      QUARKUS_HTTP_HOST: "0.0.0.0"
      QUARKUS_HTTP_PORT: "9080"

    # Secretos (referencia al Secret externo para REDHAT_TOKEN)
    secretRefs:
      - redhat-cases-mcp-secrets

    # HTTP Transport configuration
    httpTransport:
      targetPort: 9080
      path: /mcp

    # Recursos
    resources:
      requests:
        memory: "64Mi"
        cpu: "50m"
      limits:
        memory: "256Mi"
        cpu: "500m"

  # ------------------------------------------
  # Sessionize MCP Server (Quarkus Native)
  # ------------------------------------------
  sessionize:
    name: sessionize-mcp
    enabled: true
    description: "MCP Server para Sessionize - conferencias y eventos (Quarkus Native)"

    # HTTP Transport
    transportType: http

    # Imagen Quarkus Native desde GitHub Container Registry
    image:
      repository: ghcr.io/jeanlopezxyz/mcp-sessionize
      tag: "1.0.2"

    # Puerto del servidor HTTP
    port: 8080

    # Variables de entorno
    env:
      QUARKUS_HTTP_HOST: "0.0.0.0"
      QUARKUS_HTTP_PORT: "8080"
      # Event ID opcional - puede configurarse por secret o env
      # SESSIONIZE_EVENT_ID: ""

    # HTTP Transport configuration
    httpTransport:
      targetPort: 8080
      path: /mcp

    # Recursos
    resources:
      requests:
        memory: "64Mi"
        cpu: "50m"
      limits:
        memory: "256Mi"
        cpu: "500m"

# ============================================
# SECRETS
# ============================================
#
# Secrets para MCP servers que requieren autenticacion.
# En produccion, usar external-secrets-operator.
#
secrets:
  redhatCases:
    # Crear el secret desde este chart (false = usar external-secrets)
    create: false
    # Red Hat API Token
    # Obtener desde: https://access.redhat.com/management/api
    apiToken: ""

  sessionize:
    # Crear el secret desde este chart (false = usar external-secrets)
    create: false
    # Sessionize Event ID (opcional si se configura por defecto)
    eventId: ""

# ============================================
# INTEGRACION CON KAGENT
# ============================================
#
# El Agent referencia los MCPServer CRDs directamente (mismo namespace k2a).
# En el chart kagent-app, configurar mcpServers:
#
#   mcpServers:
#     prometheus:
#       enabled: true
#       name: prometheus-mcp      # Debe coincidir con servers.prometheus.name
#       tools:
#         - query
#         - queryRange
#
#     alertmanager:
#       enabled: true
#       name: alertmanager-mcp    # Debe coincidir con servers.alertmanager.name
#       tools:
#         - getAlerts
#         - getAlertGroups
#
# El Agent usa kind: MCPServer (no RemoteMCPServer) porque estan en el mismo namespace.
#
# ============================================
